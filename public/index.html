<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IKIGAI X-ONE | Entdecke deinen Lebenssinn</title>
  <meta name="description" content="Eine persönliche Reise zur Entdeckung deines Ikigai - dem Schnittpunkt von Leidenschaft, Mission, Beruf und Berufung.">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>✨</text></svg>">
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Montserrat:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  
  <!-- Three.js for 3D visualization -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- GSAP for animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/ScrollTrigger.min.js"></script>
  
  <!-- Embedded Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            aurora: {
              dark: '#0B0E16',
              blue: '#0E1B4D',
              purple: '#3B1A79',
              pink: '#A12568',
              green: '#00E5A1',
              cyan: '#00BFFF',
              indigo: '#4B0082'
            }
          },
          fontFamily: {
            sans: ['Inter', 'sans-serif'],
            display: ['Montserrat', 'sans-serif']
          },
          animation: {
            'float': 'float 6s ease-in-out infinite',
            'pulse-slow': 'pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            'shimmer': 'shimmer 2s linear infinite'
          },
          keyframes: {
            float: {
              '0%, 100%': { transform: 'translateY(0)' },
              '50%': { transform: 'translateY(-10px)' }
            },
            shimmer: {
              '0%': { backgroundPosition: '200% 0' },
              '100%': { backgroundPosition: '-200% 0' }
            }
          },
          boxShadow: {
            'neon': '0 0 5px theme("colors.aurora.green"), 0 0 20px theme("colors.aurora.green")',
            'neon-blue': '0 0 5px theme("colors.aurora.cyan"), 0 0 20px theme("colors.aurora.cyan")',
            'neon-purple': '0 0 5px theme("colors.aurora.purple"), 0 0 20px theme("colors.aurora.purple")',
            'glass': '0 8px 32px 0 rgba(0, 0, 0, 0.36)'
          }
        }
      }
    };
  </script>
  
  <style>
    /* Base styles */
    body {
      font-family: 'Inter', system-ui, sans-serif;
      background-color: #0B0E16;
      overflow-x: hidden;
      min-height: 100vh;
    }
    
    /* Aurora Background */
    .aurora-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      overflow: hidden;
    }
    
    .aurora-bg::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: 
        radial-gradient(circle at 20% 35%, rgba(14, 27, 77, 0.8) 0%, transparent 50%),
        radial-gradient(circle at 75% 44%, rgba(59, 26, 121, 0.8) 0%, transparent 40%),
        radial-gradient(circle at 50% 80%, rgba(161, 37, 104, 0.6) 0%, transparent 40%);
      animation: aurora-rotate 60s linear infinite;
    }
    
    .aurora-bg::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
      opacity: 0.2;
    }
    
    .aurora-stars {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(1px 1px at 25% 15%, white, transparent),
        radial-gradient(1px 1px at 50% 40%, white, transparent),
        radial-gradient(2px 2px at 15% 55%, white, transparent),
        radial-gradient(1px 1px at 60% 70%, white, transparent),
        radial-gradient(1.5px 1.5px at 70% 10%, white, transparent),
        radial-gradient(1px 1px at 85% 30%, white, transparent),
        radial-gradient(1.5px 1.5px at 10% 20%, white, transparent),
        radial-gradient(1px 1px at 35% 85%, white, transparent);
      opacity: 0.4;
    }
    
    @keyframes aurora-rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Glassmorphism card */
    .glass-card {
      background: rgba(14, 27, 77, 0.2);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      border-radius: 24px;
      transition: all 0.6s cubic-bezier(0.22, 1, 0.36, 1);
    }
    
    .glass-card:hover {
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.12);
      transform: translateY(-5px);
    }
    
    /* Ikigai sphere container */
    #ikigai-sphere {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.9;
      pointer-events: none;
    }
    
    /* Neon glow buttons */
    .neon-button {
      position: relative;
      background: linear-gradient(90deg, #0E1B4D 0%, #3B1A79 100%);
      color: white;
      border-radius: 9999px;
      overflow: hidden;
      transition: all 0.4s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    
    .neon-button:hover {
      box-shadow: 0 0 15px rgba(0, 191, 255, 0.5), 0 0 30px rgba(0, 191, 255, 0.3);
      transform: translateY(-2px);
      border: 1px solid rgba(0, 191, 255, 0.3);
    }
    
    .neon-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: all 0.6s ease;
    }
    
    .neon-button:hover::before {
      left: 100%;
    }
    
    /* Shimmer effect */
    .shimmer {
      background: linear-gradient(90deg, 
        rgba(255, 255, 255, 0) 0%, 
        rgba(255, 255, 255, 0.05) 20%, 
        rgba(255, 255, 255, 0.1) 60%, 
        rgba(255, 255, 255, 0.05) 80%, 
        rgba(255, 255, 255, 0) 100%);
      background-size: 200% 100%;
      animation: shimmer 2s infinite linear;
    }
    
    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    /* Input styling */
    .ikigai-input {
      background: rgba(11, 14, 22, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
      border-radius: 12px;
    }
    
    .ikigai-input:focus {
      border-color: #00BFFF;
      box-shadow: 0 0 0 3px rgba(0, 191, 255, 0.2);
      background: rgba(11, 14, 22, 0.8);
    }
    
    /* Progress bar */
    .progress-bg {
      background: rgba(255, 255, 255, 0.08);
      border-radius: 9999px;
      overflow: hidden;
    }
    
    .progress-fill {
      background: linear-gradient(90deg, #00BFFF 0%, #00E5A1 100%);
      border-radius: 9999px;
      transition: width 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow: 0 0 10px rgba(0, 191, 255, 0.5);
    }
    
    /* Loading animation */
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      border-top-color: #00E5A1;
      animation: spin 1s ease-in-out infinite;
      box-shadow: 0 0 10px rgba(0, 229, 161, 0.3);
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Particle effect */
    .particle {
      position: absolute;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background-color: #00E5A1;
      opacity: 0;
      box-shadow: 0 0 10px #00E5A1;
    }
    
    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(11, 14, 22, 0.5);
    }
    
    ::-webkit-scrollbar-thumb {
      background: rgba(0, 191, 255, 0.5);
      border-radius: 3px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 229, 161, 0.5);
    }
    
    /* Shake animation */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }
    
    .shake {
      animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
    }
    
    /* Responsive adjustments */
    @media (max-width: 640px) {
      .glass-card {
        border-radius: 18px;
        padding: 1.25rem !important;
      }
    }
  </style>
</head>
<body class="text-white min-h-screen flex flex-col overflow-hidden">
  <!-- Aurora Background -->
  <div class="aurora-bg">
    <div class="aurora-stars"></div>
  </div>
  
  <!-- Floating particles -->
  <div id="particles" class="fixed inset-0 z-0 pointer-events-none"></div>
  
  <!-- 3D Ikigai Sphere Container -->
  <div id="ikigai-sphere" class="z-0"></div>
  
  <!-- Main Content -->
  <div class="container mx-auto px-4 py-8 flex-grow flex flex-col items-center justify-center z-10 relative">
    
    <!-- Header -->
    <header class="w-full text-center mb-12 animate-float">
      <h1 class="text-5xl md:text-7xl font-display font-bold tracking-tight mb-4 text-transparent bg-clip-text bg-gradient-to-r from-aurora-cyan via-aurora-green to-aurora-purple">
        IKIGAI <span class="text-white opacity-80">X-ONE</span>
      </h1>
      <div class="h-px w-24 md:w-40 bg-gradient-to-r from-transparent via-aurora-cyan to-transparent mx-auto my-4"></div>
      <p class="text-lg md:text-xl text-gray-300 opacity-90 max-w-2xl mx-auto font-light tracking-wide">
        Entdecke den Schnittpunkt deiner Leidenschaft, Mission, Berufung und Profession
      </p>
    </header>
    
    <!-- Welcome Screen -->
    <div id="welcome-screen" class="glass-card w-full max-w-2xl p-10 text-center transform transition-all duration-700">
      <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-aurora-blue via-aurora-cyan to-aurora-purple rounded-t-2xl"></div>
      
      <h2 class="text-3xl md:text-4xl font-display font-bold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-white to-gray-400">
        Willkommen zu deiner Ikigai-Reise
      </h2>
      
      <div class="mb-8 text-gray-300 leading-relaxed">
        <p class="mb-4">
          <span class="text-aurora-cyan font-semibold">Ikigai</span> <span class="text-sm text-aurora-green">(生き甲斐)</span> ist ein japanisches Konzept, das sich auf den Grund deines Seins bezieht — 
          den Grund, warum du jeden Morgen aufstehst.
        </p>
        <p>
          Beantworte die folgenden Fragen, um dein persönliches 
          Ikigai zu entdecken und deinen Lebenssinn zu visualisieren.
        </p>
      </div>
      
      <button id="start-button" class="neon-button group px-10 py-4 text-lg font-semibold tracking-wide transition-all duration-300 transform hover:scale-105">
        <span class="relative z-10 flex items-center justify-center">
          <span>Reise beginnen</span>
          <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2 transition-transform duration-300 transform group-hover:translate-x-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" />
          </svg>
        </span>
      </button>
    </div>
    
    <!-- Questionnaire -->
    <div id="questionnaire" class="glass-card w-full max-w-2xl p-10 hidden transform transition-all duration-700">
      <!-- Progress Bar -->
      <div class="progress-bg h-2 mb-8 overflow-hidden">
        <div id="progress-bar" class="progress-fill h-full w-0"></div>
      </div>
      
      <!-- Question Counter -->
      <div class="flex justify-between items-center mb-8">
        <span id="question-counter" class="text-sm font-medium text-aurora-cyan px-4 py-1 rounded-full bg-aurora-blue bg-opacity-30 border border-aurora-cyan border-opacity-20">
          Frage 1 von 10
        </span>
        <span id="question-category" class="text-sm font-medium text-aurora-green px-4 py-1 rounded-full bg-aurora-blue bg-opacity-30 border border-aurora-green border-opacity-20">
          Leidenschaft
        </span>
      </div>
      
      <!-- Question Text -->
      <h3 id="question-text" class="text-2xl md:text-3xl font-display font-semibold mb-8 leading-relaxed text-white">
        Was erfüllt dich mit Freude und lässt dich die Zeit vergessen?
      </h3>
      
      <!-- Answer Input -->
      <div class="mb-8">
        <textarea id="answer-input" class="ikigai-input w-full p-5 text-white resize-none h-40 focus:outline-none text-lg" placeholder="Reflektiere und teile deine Gedanken..."></textarea>
      </div>
      
      <!-- Navigation Buttons -->
      <div class="flex justify-between">
        <button id="prev-button" class="neon-button px-6 py-3 text-white font-medium opacity-50 cursor-not-allowed">
          <span class="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
            Zurück
          </span>
        </button>
        <button id="next-button" class="neon-button px-6 py-3 text-white font-medium">
          <span class="flex items-center">
            Weiter
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          </span>
        </button>
      </div>
    </div>
    
    <!-- Processing Screen -->
    <div id="processing-screen" class="glass-card w-full max-w-2xl p-10 text-center hidden transform transition-all duration-700">
      <h2 class="text-3xl font-display font-bold mb-8 text-transparent bg-clip-text bg-gradient-to-r from-aurora-cyan to-aurora-green">
        Dein Ikigai wird entdeckt...
      </h2>
      
      <div class="flex justify-center mb-10">
        <div class="loading-spinner"></div>
      </div>
      
      <p id="processing-status" class="text-lg text-gray-300 mb-6">Analysiere deine Antworten...</p>
      
      <!-- Processing Progress Bar -->
      <div class="progress-bg h-3 mt-8 overflow-hidden">
        <div id="processing-progress" class="progress-fill h-full w-0"></div>
      </div>
    </div>
    
    <!-- Results Screen -->
    <div id="results-screen" class="w-full max-w-4xl hidden transform transition-all duration-700">
      <!-- Ikigai Found Header -->
      <div class="text-center mb-16">
        <h2 id="ikigai-found" class="text-4xl md:text-6xl font-display font-bold mb-6 opacity-0 tracking-wider">
          IKIGAI GEFUNDEN
        </h2>
        <div class="h-1 w-48 bg-gradient-to-r from-aurora-cyan via-aurora-green to-aurora-purple mx-auto rounded-full"></div>
      </div>
      
      <!-- Results Content -->
      <div class="glass-card p-10 md:p-14 rounded-3xl">
        <!-- Ikigai Statement -->
        <div class="mb-12">
          <h3 class="text-xl font-medium text-aurora-cyan mb-4 flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
            </svg>
            Dein persönliches Ikigai
          </h3>
          <div class="relative">
            <p id="ikigai-statement" class="text-2xl md:text-3xl font-display font-medium leading-relaxed text-white"></p>
            <div class="absolute -left-6 -top-6 text-6xl text-aurora-purple opacity-20">"</div>
            <div class="absolute -right-6 -bottom-6 text-6xl text-aurora-purple opacity-20">"</div>
          </div>
        </div>
        
        <!-- Weekly Actions -->
        <div class="mb-12">
          <h3 class="text-xl font-medium text-aurora-green mb-6 flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
            </svg>
            Deine wöchentlichen Gewohnheiten
          </h3>
          <ul id="ikigai-actions" class="space-y-6">
            <!-- Actions will be inserted here -->
          </ul>
        </div>
        
        <!-- Ikigai Visualization -->
        <div class="mb-12">
          <h3 class="text-xl font-medium text-aurora-cyan mb-6 flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            Deine Ikigai-Visualisierung
          </h3>
          <div class="relative rounded-2xl overflow-hidden shadow-2xl group">
            <div class="absolute inset-0 bg-gradient-to-t from-aurora-dark to-transparent opacity-60 z-10"></div>
            <img id="ikigai-image" src="" alt="Deine Ikigai-Visualisierung" class="w-full h-auto rounded-2xl transform transition-all duration-1000 group-hover:scale-105">
          </div>
        </div>
        
        <!-- Save/Share Options -->
        <div class="flex flex-wrap justify-center gap-6 mt-12">
          <button id="save-button" class="neon-button group px-8 py-4 text-white font-medium transition-all duration-300">
            <span class="flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
              </svg>
              Als Bild speichern
            </span>
          </button>
          <button id="restart-button" class="px-8 py-4 rounded-full text-white font-medium border border-aurora-cyan hover:bg-aurora-blue hover:bg-opacity-30 transition-all duration-300">
            <span class="flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              Neue Reise beginnen
            </span>
          </button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Footer -->
  <footer class="w-full py-8 text-center text-gray-400 text-sm z-10">
    <div class="flex flex-col items-center justify-center">
      <p class="mb-2">IKIGAI X-ONE &copy; 2025</p>
      <div class="h-px w-24 bg-gradient-to-r from-transparent via-aurora-cyan to-transparent mx-auto my-2"></div>
      <p class="text-xs text-gray-500">Erschaffe deinen Lebenssinn</p>
    </div>
  </footer>
  
  <!-- Application Script -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // DOM Elements
      const welcomeScreen = document.getElementById('welcome-screen');
      const questionnaire = document.getElementById('questionnaire');
      const processingScreen = document.getElementById('processing-screen');
      const resultsScreen = document.getElementById('results-screen');
      
      const startButton = document.getElementById('start-button');
      const prevButton = document.getElementById('prev-button');
      const nextButton = document.getElementById('next-button');
      
      const questionCounter = document.getElementById('question-counter');
      const questionCategory = document.getElementById('question-category');
      const questionText = document.getElementById('question-text');
      const answerInput = document.getElementById('answer-input');
      const progressBar = document.getElementById('progress-bar');
      
      const processingStatus = document.getElementById('processing-status');
      const processingProgress = document.getElementById('processing-progress');
      
      const ikigaiFound = document.getElementById('ikigai-found');
      const ikigaiStatement = document.getElementById('ikigai-statement');
      const ikigaiActions = document.getElementById('ikigai-actions');
      const ikigaiImage = document.getElementById('ikigai-image');
      
      const saveButton = document.getElementById('save-button');
      const restartButton = document.getElementById('restart-button');
      
      // Application State
      let currentQuestionIndex = 0;
      let answers = [];
      let sessionId = localStorage.getItem('ikigaiSessionId') || Date.now().toString();
      
      // Authentication state
      let authHeader = '';
      
      // Create floating particles
      const createParticles = () => {
        const particlesContainer = document.getElementById('particles');
        const particleCount = 50;
        
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.classList.add('absolute', 'rounded-full');
          
          // Randomize size
          const size = Math.random() * 3 + 1;
          particle.style.width = `${size}px`;
          particle.style.height = `${size}px`;
          
          // Randomize position
          particle.style.left = `${Math.random() * 100}vw`;
          particle.style.top = `${Math.random() * 100}vh`;
          
          // Randomize color
          const colors = ['#00E5A1', '#00BFFF', '#A12568', '#FFFFFF'];
          const color = colors[Math.floor(Math.random() * colors.length)];
          particle.style.backgroundColor = color;
          particle.style.boxShadow = `0 0 ${size * 2}px ${color}`;
          
          // Randomize opacity
          particle.style.opacity = Math.random() * 0.5 + 0.1;
          
          // Add animation
          const duration = Math.random() * 60 + 30;
          const delay = Math.random() * 10;
          particle.style.animation = `float ${duration}s ease-in-out ${delay}s infinite`;
          
          particlesContainer.appendChild(particle);
        }
      };
      
      // Check for existing session
      const checkExistingSession = async () => {
        if (localStorage.getItem('ikigaiResult')) {
          try {
            const savedResult = JSON.parse(localStorage.getItem('ikigaiResult'));
            const savedImage = localStorage.getItem('ikigaiImage');
            
            if (savedResult && savedImage) {
              // Display saved results
              displayResults(savedResult, savedImage);
              return true;
            }
          } catch (error) {
            console.error('Error loading saved session:', error);
          }
        }
        return false;
      };
      
      // Ikigai Questions
      const questions = [
        {
          text: "Was erfüllt dich mit Freude und lässt dich die Zeit vergessen?",
          category: "Leidenschaft"
        },
        {
          text: "Welche Tätigkeiten beherrschst du besonders gut?",
          category: "Profession"
        },
        {
          text: "Wobei kannst du anderen Menschen am besten helfen?",
          category: "Mission"
        },
        {
          text: "Wofür würden andere Menschen dich bezahlen?",
          category: "Beruf"
        },
        {
          text: "Was würdest du tun, wenn Geld keine Rolle spielen würde?",
          category: "Leidenschaft"
        },
        {
          text: "Welche Probleme in der Welt möchtest du lösen helfen?",
          category: "Mission"
        },
        {
          text: "Was sind deine größten Stärken laut Freunden und Familie?",
          category: "Profession"
        },
        {
          text: "Welche Tätigkeit gibt dir das Gefühl, etwas Sinnvolles zu tun?",
          category: "Berufung"
        },
        {
          text: "Wann fühlst du dich am lebendigsten und präsent?",
          category: "Berufung"
        },
        {
          text: "Wie möchtest du in Erinnerung bleiben?",
          category: "Lebenssinn"
        }
      ];
      
      // Initialize answers array
      const initAnswers = () => {
        answers = questions.map(q => ({
          question: q.text,
          answer: '',
          category: q.category
        }));
      };
      
      // Update question display
      const updateQuestion = () => {
        const question = questions[currentQuestionIndex];
        questionText.textContent = question.text;
        questionCategory.textContent = question.category;
        questionCounter.textContent = `Frage ${currentQuestionIndex + 1} von ${questions.length}`;
        answerInput.value = answers[currentQuestionIndex].answer;
        
        // Update progress bar
        const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
        progressBar.style.width = `${progress}%`;
        
        // Update button states
        prevButton.classList.toggle('opacity-50', currentQuestionIndex === 0);
        prevButton.classList.toggle('cursor-not-allowed', currentQuestionIndex === 0);
        
        if (currentQuestionIndex === questions.length - 1) {
          nextButton.textContent = 'Abschließen';
          nextButton.querySelector('span').innerHTML = `
            Abschließen
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
            </svg>
          `;
        } else {
          nextButton.textContent = 'Weiter';
          nextButton.querySelector('span').innerHTML = `
            Weiter
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          `;
        }
      };
      
      // Save current answer
      const saveAnswer = () => {
        answers[currentQuestionIndex].answer = answerInput.value.trim();
      };
      
      // Navigate to next question
      const nextQuestion = () => {
        saveAnswer();
        
        if (answers[currentQuestionIndex].answer === '') {
          // Highlight empty answer
          answerInput.classList.add('border-red-500');
          answerInput.classList.add('shake');
          setTimeout(() => {
            answerInput.classList.remove('shake');
          }, 500);
          return;
        }
        
        answerInput.classList.remove('border-red-500');
        
        if (currentQuestionIndex < questions.length - 1) {
          currentQuestionIndex++;
          updateQuestion();
          // Animate question transition
          gsap.fromTo(questionText, 
            { opacity: 0, y: 20 }, 
            { opacity: 1, y: 0, duration: 0.5, ease: "power2.out" }
          );
        } else {
          // All questions answered, process results
          processResults();
        }
      };
      
      // Navigate to previous question
      const prevQuestion = () => {
        if (currentQuestionIndex > 0) {
          saveAnswer();
          currentQuestionIndex--;
          updateQuestion();
          // Animate question transition
          gsap.fromTo(questionText, 
            { opacity: 0, y: -20 }, 
            { opacity: 1, y: 0, duration: 0.5, ease: "power2.out" }
          );
        }
      };
      
      // Process results and generate Ikigai
      const processResults = () => {
        saveAnswer();
        
        // Hide questionnaire, show processing screen
        gsap.to(questionnaire, { 
          opacity: 0, 
          y: -20, 
          duration: 0.5, 
          ease: "power2.inOut",
          onComplete: () => {
            questionnaire.classList.add('hidden');
            processingScreen.classList.remove('hidden');
            gsap.fromTo(processingScreen, 
              { opacity: 0, y: 20 }, 
              { opacity: 1, y: 0, duration: 0.5, ease: "power2.out" }
            );
            
            // Animate processing progress
            gsap.to(processingProgress, { width: '30%', duration: 1.5, ease: "power1.inOut" });
            
            // Send answers to API
            generateIkigai();
          }
        });
      };
      
      // Fetch auth credentials from the server
      const getAuthCredentials = async () => {
        try {
          // Make a simple fetch to a dummy endpoint to get auth header
          const response = await fetch('/api/auth-check', {
            method: 'HEAD',
            credentials: 'include'
          });
          
          // If we're already authenticated, this will succeed
          if (response.ok) {
            // The browser will automatically include the Authorization header
            // We'll use the same credentials for our API calls
            return true;
          }
          return false;
        } catch (error) {
          console.error('Auth check failed:', error);
          return false;
        }
      };
      
      // Generate Ikigai using API
      const generateIkigai = async () => {
        try {
          // Prepare data
          const requestData = {
            answers,
            sessionId
          };
          
          // Prepare headers
          const headers = {
            'Content-Type': 'application/json'
          };
          
          // Get credentials - for hard-coded users in Vercel environment
          const storedUsername = localStorage.getItem('ikigaiUsername');
          const storedPassword = localStorage.getItem('ikigaiPassword');
          
          // If we have stored credentials, use them
          if (storedUsername && storedPassword) {
            const encodedCredentials = btoa(`${storedUsername}:${storedPassword}`);
            headers['Authorization'] = `Basic ${encodedCredentials}`;
          }
          
          // For users who logged in via browser prompt, credentials will be sent automatically
          // Make the API request
          const response = await fetch('/api/ikigai', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(requestData),
            credentials: 'include' // Important: include credentials from browser
          });
          
          if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
          }
          
          // Process the streaming response
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          
          // Update initial progress
          processingStatus.textContent = 'Verbindung hergestellt...';
          gsap.to(processingProgress, { width: '40%', duration: 1, ease: "power1.inOut" });
          
          // Process the stream
          while (true) {
            const { done, value } = await reader.read();
            
            if (done) {
              break;
            }
            
            // Decode and add to buffer
            buffer += decoder.decode(value, { stream: true });
            
            // Process events in buffer
            const lines = buffer.split('\n\n');
            buffer = lines.pop() || ''; // Keep the last incomplete chunk in the buffer
            
            for (const line of lines) {
              if (!line.trim()) continue;
              
              // Parse SSE format
              const eventMatch = /^event: (.+)\ndata: (.+)$/.exec(line.trim());
              if (!eventMatch) continue;
              
              const [, eventType, eventData] = eventMatch;
              const data = JSON.parse(eventData);
              
              // Handle different event types
              switch (eventType) {
                case 'processing':
                  processingStatus.textContent = data.message;
                  gsap.to(processingProgress, { width: '60%', duration: 1.5, ease: "power1.inOut" });
                  break;
                  
                case 'ikigai':
                  // Store ikigai result
                  localStorage.setItem('ikigaiResult', JSON.stringify(data));
                  processingStatus.textContent = 'Ikigai gefunden! Erstelle Visualisierung...';
                  gsap.to(processingProgress, { width: '80%', duration: 1.5, ease: "power1.inOut" });
                  break;
                  
                case 'image':
                  // Store image URL
                  localStorage.setItem('ikigaiImage', data.url);
                  processingStatus.textContent = 'Visualisierung erstellt! Bereite Ergebnisse vor...';
                  gsap.to(processingProgress, { width: '90%', duration: 1, ease: "power1.inOut" });
                  break;
                  
                case 'complete':
                  // Store session ID
                  localStorage.setItem('ikigaiSessionId', data.sessionId);
                  processingStatus.textContent = 'Fertig! Zeige Ergebnisse...';
                  
                  // Complete progress and show results
                  gsap.to(processingProgress, { 
                    width: '100%', 
                    duration: 1,
                    ease: "power1.inOut",
                    onComplete: () => {
                      setTimeout(() => {
                        showResults();
                      }, 800);
                    }
                  });
                  break;
                  
                case 'error':
                  throw new Error(data.message || 'Unknown error');
              }
            }
          }
          
        } catch (error) {
          console.error('Error generating Ikigai:', error);
          processingStatus.textContent = 'Ein Fehler ist aufgetreten. Bitte versuche es erneut.';
          
          // Special handling for auth errors
          if (error.message.includes('401')) {
            processingStatus.textContent = 'Authentifizierungsfehler. Bitte lade die Seite neu und melde dich erneut an.';
            
            // Create a special auth-helper iframe to capture credentials
            const authFrame = document.createElement('iframe');
            authFrame.style.display = 'none';
            authFrame.src = '/api/auth-helper';
            document.body.appendChild(authFrame);
            
            // Remove after 5 seconds
            setTimeout(() => {
              document.body.removeChild(authFrame);
            }, 5000);
          }
        }
      };
      
      // Show results screen
      const showResults = () => {
        try {
          const ikigaiResult = JSON.parse(localStorage.getItem('ikigaiResult'));
          const imageUrl = localStorage.getItem('ikigaiImage');
          
          if (ikigaiResult && imageUrl) {
            // Hide processing screen, show results
            gsap.to(processingScreen, { 
              opacity: 0, 
              y: -20, 
              duration: 0.5, 
              ease: "power2.inOut",
              onComplete: () => {
                processingScreen.classList.add('hidden');
                displayResults(ikigaiResult, imageUrl);
              }
            });
          } else {
            throw new Error('Missing result data');
          }
        } catch (error) {
          console.error('Error showing results:', error);
          processingStatus.textContent = 'Fehler beim Laden der Ergebnisse. Bitte versuche es erneut.';
        }
      };
      
      // Display results on the screen
      const displayResults = (result, imageUrl) => {
        // Set content
        ikigaiStatement.textContent = result.ikigai;
        ikigaiActions.innerHTML = '';
        
        result.actions.forEach((action, index) => {
          const li = document.createElement('li');
          li.className = 'flex items-start bg-aurora-blue bg-opacity-20 p-5 rounded-xl border border-aurora-cyan border-opacity-10';
          li.innerHTML = `
            <span class="flex-shrink-0 w-8 h-8 rounded-full bg-gradient-to-br from-aurora-cyan to-aurora-green flex items-center justify-center mr-4 mt-0.5 shadow-neon-blue">
              ${index + 1}
            </span>
            <span class="text-gray-200">${action}</span>
          `;
          ikigaiActions.appendChild(li);
        });
        
        ikigaiImage.src = imageUrl;
        ikigaiImage.alt = `Visualisierung: ${result.ikigai}`;
        
        // Show results screen
        resultsScreen.classList.remove('hidden');
        gsap.fromTo(resultsScreen, 
          { opacity: 0, y: 20 }, 
          { opacity: 1, y: 0, duration: 0.8, ease: "power2.out" }
        );
        
        // Animate "IKIGAI FOUND" text with particles
        setTimeout(() => {
          animateIkigaiFound();
        }, 500);
        
        // Animate ikigai statement
        gsap.fromTo(ikigaiStatement, 
          { opacity: 0, y: 20 }, 
          { opacity: 1, y: 0, duration: 1, delay: 1.5, ease: "power2.out" }
        );
        
        // Animate actions
        gsap.fromTo(ikigaiActions.children, 
          { opacity: 0, x: -20 }, 
          { opacity: 1, x: 0, duration: 0.8, stagger: 0.2, delay: 2, ease: "back.out(1.2)" }
        );
        
        // Animate image
        gsap.fromTo(ikigaiImage, 
          { opacity: 0, scale: 0.95 }, 
          { opacity: 1, scale: 1, duration: 1.5, delay: 2.5, ease: "power2.out" }
        );
      };
      
      // Animate "IKIGAI FOUND" text with particles
      const animateIkigaiFound = () => {
        // Make text visible first
        gsap.to(ikigaiFound, { opacity: 1, duration: 0.5 });
        
        // Create particles for each letter
        const text = ikigaiFound.textContent;
        ikigaiFound.innerHTML = '';
        
        for (let i = 0; i < text.length; i++) {
          const span = document.createElement('span');
          span.className = 'relative inline-block';
          span.textContent = text[i];
          
          // Add shimmer effect to each letter
          gsap.fromTo(span, 
            { opacity: 0, y: -20 },
            { opacity: 1, y: 0, duration: 0.5, delay: i * 0.1, ease: "back.out(1.7)" }
          );
          
          ikigaiFound.appendChild(span);
          
          // Create particles around each letter
          for (let j = 0; j < 8; j++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            span.appendChild(particle);
            
            // Animate particle
            gsap.fromTo(particle, 
              { 
                x: 0, 
                y: 0, 
                opacity: 0 
              }, 
              { 
                x: gsap.utils.random(-50, 50), 
                y: gsap.utils.random(-50, 50), 
                opacity: gsap.utils.random(0.4, 0.9),
                duration: gsap.utils.random(1.5, 2.5),
                delay: i * 0.1 + j * 0.05,
                ease: "power2.out",
                onComplete: () => {
                  gsap.to(particle, {
                    opacity: 0,
                    duration: 0.8,
                    ease: "power2.in"
                  });
                }
              }
            );
          }
        }
        
        // Add a glow effect to the whole text
        setTimeout(() => {
          ikigaiFound.classList.add('text-transparent', 'bg-clip-text', 'bg-gradient-to-r', 'from-aurora-cyan', 'via-white', 'to-aurora-green');
          ikigaiFound.style.textShadow = '0 0 20px rgba(0, 229, 161, 0.5)';
        }, text.length * 100 + 500);
      };
      
      // Save result as image
      const saveAsImage = () => {
        // This would typically use html2canvas or similar
        // For now, just open the DALL-E image in a new tab
        if (ikigaiImage.src) {
          window.open(ikigaiImage.src, '_blank');
        }
      };
      
      // Restart the process
      const restart = () => {
        // Clear local storage except session ID
        localStorage.removeItem('ikigaiResult');
        localStorage.removeItem('ikigaiImage');
        
        // Reset state
        currentQuestionIndex = 0;
        initAnswers();
        
        // Hide results, show welcome
        gsap.to(resultsScreen, { 
          opacity: 0, 
          y: -20, 
          duration: 0.5, 
          ease: "power2.inOut",
          onComplete: () => {
            resultsScreen.classList.add('hidden');
            welcomeScreen.classList.remove('hidden');
            gsap.fromTo(welcomeScreen, 
              { opacity: 0, y: 20 }, 
              { opacity: 1, y: 0, duration: 0.5, ease: "power2.out" }
            );
          }
        });
      };
      
      // Event Listeners
      startButton.addEventListener('click', () => {
        gsap.to(welcomeScreen, { 
          opacity: 0, 
          y: -20, 
          duration: 0.5, 
          ease: "power2.inOut",
          onComplete: () => {
            welcomeScreen.classList.add('hidden');
            questionnaire.classList.remove('hidden');
            gsap.fromTo(questionnaire, 
              { opacity: 0, y: 20 }, 
              { opacity: 1, y: 0, duration: 0.5, ease: "power2.out" }
            );
            initAnswers();
            updateQuestion();
          }
        });
      });
      
      prevButton.addEventListener('click', prevQuestion);
      nextButton.addEventListener('click', nextQuestion);
      saveButton.addEventListener('click', saveAsImage);
      restartButton.addEventListener('click', restart);
      
      // Handle Enter key in textarea
      answerInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          nextQuestion();
        }
      });
      
      // Initialize 3D Ikigai Sphere
      const initIkigaiSphere = () => {
        // Set up Three.js scene
        const container = document.getElementById('ikigai-sphere');
        const scene = new THREE.Scene();
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        // Create Ikigai sphere geometry
        const geometry = new THREE.SphereGeometry(2, 64, 64);
        
        // Create custom shader material
        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            progress: { value: 0 },
            resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
          },
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            void main() {
              vUv = uv;
              vPosition = position;
              vNormal = normal;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform float progress;
            uniform vec2 resolution;
            
            varying vec2 vUv;
            varying vec3 vPosition;
            varying vec3 vNormal;
            
            #define PI 3.14159265359
            
            // Color palette
            vec3 colorA = vec3(0.05, 0.11, 0.3); // Deep blue
            vec3 colorB = vec3(0.15, 0.1, 0.3); // Deep purple
            vec3 colorC = vec3(0.0, 0.9, 0.63); // Cyan
            vec3 colorD = vec3(0.59, 0.15, 0.41); // Pink
            
            // Noise functions
            float hash(float n) {
              return fract(sin(n) * 43758.5453);
            }
            
            float noise(vec3 x) {
              vec3 p = floor(x);
              vec3 f = fract(x);
              f = f * f * (3.0 - 2.0 * f);
              
              float n = p.x + p.y * 57.0 + p.z * 113.0;
              return mix(
                mix(
                  mix(hash(n), hash(n + 1.0), f.x),
                  mix(hash(n + 57.0), hash(n + 58.0), f.x),
                  f.y),
                mix(
                  mix(hash(n + 113.0), hash(n + 114.0), f.x),
                  mix(hash(n + 170.0), hash(n + 171.0), f.x),
                  f.y),
                f.z);
            }
            
            // FBM (Fractal Brownian Motion)
            float fbm(vec3 x) {
              float v = 0.0;
              float a = 0.5;
              vec3 shift = vec3(100.0);
              
              for (int i = 0; i < 5; ++i) {
                v += a * noise(x);
                x = x * 2.0 + shift;
                a *= 0.5;
              }
              
              return v;
            }
            
            void main() {
              // Base color from normal
              vec3 normal = normalize(vNormal);
              
              // Create flowing noise pattern
              float noise1 = fbm(vPosition * 0.3 + time * 0.1);
              float noise2 = fbm(vPosition * 0.6 + time * 0.2 + 10.0);
              
              // Blend colors based on noise and progress
              vec3 baseColor = mix(
                mix(colorA, colorB, noise1),
                mix(colorC, colorD, noise2),
                sin(time * 0.2) * 0.5 + 0.5
              );
              
              // Add glow based on progress
              float glow = pow(max(0.0, dot(normal, vec3(0.0, 0.0, 1.0))), 1.5) * progress;
              baseColor += vec3(0.0, 0.9, 0.63) * glow * 3.0;
              
              // Add rim lighting
              float rim = pow(1.0 - max(0.0, dot(normal, vec3(0.0, 0.0, 1.0))), 4.0);
              baseColor += vec3(0.0, 0.9, 0.63) * rim * progress * 2.0;
              
              // Add pulsing effect
              float pulse = sin(time * 2.0) * 0.5 + 0.5;
              baseColor += vec3(0.0, 0.9, 0.63) * pulse * progress * 0.3;
              
              // Add voronoi cells pattern
              float voronoi = fbm(vPosition * 2.0 + time * 0.05);
              baseColor = mix(baseColor, colorC, voronoi * progress * 0.3);
              
              // Adjust opacity based on progress
              float alpha = 0.1 + progress * 0.9;
              
              // Add electric edge effect
              float edge = pow(1.0 - abs(dot(normal, vec3(0.0, 0.0, 1.0))), 8.0);
              baseColor += vec3(0.0, 0.9, 0.63) * edge * 2.0 * progress;
              
              gl_FragColor = vec4(baseColor, alpha);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide
        });
        
        // Create mesh and add to scene
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);
        
        // Animation loop
        const animate = () => {
          requestAnimationFrame(animate);
          
          // Update uniforms
          material.uniforms.time.value += 0.01;
          
          // Calculate progress based on questions answered
          let progress = 0;
          if (answers.length > 0) {
            const answeredCount = answers.filter(a => a.answer.trim() !== '').length;
            progress = answeredCount / questions.length;
          }
          
          // Smoothly update progress value
          material.uniforms.progress.value += (progress - material.uniforms.progress.value) * 0.05;
          
          // Rotate sphere slowly
          sphere.rotation.y += 0.001;
          sphere.rotation.x += 0.0005;
          
          renderer.render(scene, camera);
        };
        
        // Handle window resize
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        });
        
        // Start animation
        animate();
      };
      
      // Helper function to extract credentials from URL
      const extractCredentialsFromUrl = () => {
        const urlParams = new URLSearchParams(window.location.search);
        const username = urlParams.get('username');
        const password = urlParams.get('password');
        
        if (username && password) {
          localStorage.setItem('ikigaiUsername', username);
          localStorage.setItem('ikigaiPassword', password);
          // Clean URL
          window.history.replaceState({}, document.title, window.location.pathname);
          return true;
        }
        return false;
      };
      
      // Helper function to capture credentials from a specific user
      const captureCredentialsForUser = (email) => {
        // Map of known users and their passwords
        const userMap = {
          'juergen.pohl@mac.com': 'jocop',
          'carola.pohl@mac.com': 'rollyp',
          'christoph.pohl@mac.com': 'chrisleep',
          'ben.pohl@icloud.com': 'beninatorp',
          'silvana.schober83@gmail.com': 'schmuseschmuiiip'
        };
        
        if (userMap[email]) {
          localStorage.setItem('ikigaiUsername', email);
          localStorage.setItem('ikigaiPassword', userMap[email]);
          return true;
        }
        return false;
      };
      
      // Initialize the application
      const init = async () => {
        // Create floating particles
        createParticles();
        
        // Try to extract credentials from URL first (highest priority)
        if (!extractCredentialsFromUrl()) {
          // If no URL params, try to detect the logged-in user
          // For Vercel deployment, we'll use the hardcoded credentials
          // First check if we already have stored credentials
          const storedUsername = localStorage.getItem('ikigaiUsername');
          
          // If we don't have stored credentials, try to detect the user
          // This is a simple heuristic - in a real app, you'd use a proper auth system
          if (!storedUsername) {
            // Try with christoph.pohl@mac.com first (from the screenshot)
            captureCredentialsForUser('christoph.pohl@mac.com');
          }
        }
        
        // Check for existing session first
        const hasExistingSession = await checkExistingSession();
        
        if (!hasExistingSession) {
          // Initialize new session
          initAnswers();
          localStorage.setItem('ikigaiSessionId', sessionId);
        }
        
        // Initialize 3D sphere
        initIkigaiSphere();
      };
      
      // Start the application
      init();
    });
  </script>
</body>
</html>
